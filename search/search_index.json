{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>A simple build tool for ALICE experiment software and its externals. Recipes for the externals and ALICE software are stored in alidist.</p> <p>You can install aliBuild on Ubuntu, MacOS, CentOS 7, Alma 8, Alma 9 and Fedora.</p> <p>Then, build ALICE's software with:</p> <pre><code>git clone https://github.com/alisw/alidist.git\naliBuild build O2Physics\n</code></pre> <p>For a more verbose documentation of what is happening have a look at the quickstart guide. See the user guide for more command line options or have a look at the troubleshooting pages for hints on how to debug build errors. Have a look at the reference guide if you want to package your own software.</p> Simple build recipes       Build recipes are simple bash scripts with a YAML header. Whenever       a dependency or a package changes only what is affected by the       change is rebuilt.       Read more Reuses system tools       If desired, aliBuild will do its best to reuse what is available       on the system, if compatible to what is found in the recipe.       Read more Docker support       aliBuild allows builds to happen inside a docker container, so       that you can develop on Mac and build on your production Linux       platform.       Read more Binary packages       aliBuild provides the ability to reuse binary packages which were       previously centrally built, when they match the one that would be       built locally.       Read more Developer mode       Besides building and packaging your dependencies, aliBuild       provides you the ability to develop those via a simple git clone.       Read more Integrates with modules       Easily setup your work environment using `alienv`, which is based on       standard modulefiles.       Read more"},{"location":"quick.html","title":"Quickstart","text":"<p>aliBuild is a tool to simplify building and installing ALICE / ALFA software. This is a quickstart Guide which will show you how to build and use a package, for extended documentation please have a look at the user guide.</p>"},{"location":"quick.html#setting-up","title":"Setting up","text":"<p>The tool itself is available as a standard PyPi package. You can install it via:</p> <pre><code>pip install alibuild\n</code></pre> <p>Alternatively, if you cannot use pip, you can checkout the Github repository and use it from there:</p> <pre><code>git clone https://github.com/alisw/alibuild.git\n</code></pre> <p>This will provide you the tool itself. </p> <p>In order to work you will need a set of recipes from a repository called alidist. On the first invocation of <code>alibuild</code> the recipes will be downloaded and put in a <code>alidist</code> folder.  In case you need to use a special branch / repository you can always <code>git clone</code>  the repository yourself. By default alibuild will pickup the recipes found in <code>$PWD/alidist</code>.</p>"},{"location":"quick.html#building-a-package","title":"Building a package","text":"<p>Once you have obtained both repository, you can trigger a build via:</p> <pre><code>aliBuild [-d] -j &lt;jobs&gt; build &lt;package&gt;\n</code></pre> <p>(or alibuild/aliBuild if you are working from sources) where:</p> <ul> <li><code>&lt;package&gt;</code>: is the name of the package you want to build, e.g.: </li> <li><code>AliRoot</code></li> <li><code>AliPhysics</code></li> <li><code>O2</code></li> <li><code>ROOT</code></li> <li><code>-d</code> can be used to have verbose debug output.</li> <li><code>&lt;jobs&gt;</code> is the maximum number of parallel processes to be used for   building where possible (defaults to the number of CPUs available if   omitted).</li> </ul> <p>If you need to modify the compile options, you can do so by looking at the recipes in your local <code>alidist</code> folder and amend them.</p>"},{"location":"quick.html#results-of-a-build","title":"Results of a build","text":"<p>By default (can be changed using the <code>-c</code> option) the installation of your builds can be found in:</p> <pre><code>sw/&lt;architecture&gt;/&lt;package-name&gt;/&lt;package-version&gt;-&lt;revision&gt;/\n</code></pre> <p>where:</p> <ul> <li><code>&lt;architecture&gt;</code> is the same as the one passed via the <code>-a</code> option.</li> <li><code>&lt;package-name&gt;</code>: is the same as the one passed as an argument.</li> <li><code>&lt;package-version&gt;</code>: is the same as the one found in the related recipe in alidist.</li> <li><code>&lt;package-revision&gt;</code>: is the number of times you rebuilt the same version of   a package, using a different recipe. In general this will be 1.</li> </ul> <p>For example, on Centos7:</p> <pre><code>sw/slc7_x86-64/AliRoot/v6-16-01-1\n</code></pre>"},{"location":"quick.html#using-the-built-package","title":"Using the built package","text":"<p>Environment for packages built using aliBuild is managed by Environment Modules and a wrapper script called alienv. Notice you will need the package <code>environment-modules</code> on Linux or <code>modules</code> on macOS for the following to work.</p> <p>Assuming you are in the toplevel directory containing <code>alibuild</code>, <code>alidist</code> and <code>sw</code> you can do:</p> <pre><code>alienv q\n</code></pre> <p>to list the available packages, and:</p> <pre><code>alienv enter VO_ALICE@PackageA::VersionA[,VO_ALICE@PackageB::VersionB...]\n</code></pre> <p>to enter a shell with the appropriate environment set. To learn more about alienv you can also look at the user guide.</p>"},{"location":"reference.html","title":"Reference","text":"<ol> <li>Recipe formats<ol> <li>The header</li> <li>The body</li> <li>Defaults, common requirements for builds</li> </ol> </li> <li>Relocation</li> </ol>"},{"location":"reference.html#recipe-formats","title":"Recipe formats","text":"<p>The recipes are found in the a separate repository. The repository can be specified via the <code>-c</code> option and defaults to alidist.</p> <p>The recipes themselves are called <code>&lt;package&gt;.sh</code> where <code>&lt;package&gt;</code> is the name of the package whose build recipe is described. Please note that all recipe filenames are lowercase: e.g. the recipe for <code>ROOT</code> will be in <code>root.sh</code>.</p> <p>The recipe itself is made up of two parts: an header, and the actual build script, separated by three dashes (<code>---</code>) standalone.</p> <p>The header is in YAML format and contains metadata about the package, like its name, version and where to find the sources.</p> <p>The build script is a standard build script which is invoked by the tool to perform the build itself. A few environment variable can be expected to be defined when the script is invoked.</p> <p>An example recipe for <code>zlib</code> is the following:</p> <pre><code>package: zlib\nversion: v1.2.8\nsource: https://github.com/madler/zlib\ntag: v1.2.8\n---\n#!/bin/bash -ex\n./configure --prefix=$INSTALLROOT\nmake ${JOBS+-j $JOBS}\nmake install\n</code></pre>"},{"location":"reference.html#the-header","title":"The header","text":"<p>The following entries are mandatory in the header:</p> <ul> <li><code>package</code>: the name of the package</li> <li> <p><code>version</code>: a mnemonic for the version which will be used in the name     of the package. Notice you can actually use some special formatting     substitutions which will be replaced with the associated value on build.     Valid substitutions are:</p> <ul> <li><code>%(branch_basename)s</code>: the name of the current alidist branch, without     the leading <code>refs/heads/</code>.</li> <li><code>%(branch_stream)s</code>: in case the alidist branch ends in <code>-patches</code>, the     name of branch without <code>-patches</code>. If the branch does not end in     <code>-patches</code>, the <code>tag</code> field of the recipe is used.</li> <li><code>%(commit_hash)s</code>: if the <code>tag</code> field is a git tag, then the tag name.     If it is a branch or raw git commit hash instead, then the raw git     commit hash pointing to the <code>HEAD</code> of that branch, or said commit hash.</li> <li><code>%(short_hash)s</code>: like <code>%(commit_hash)s</code>, but cut off after 10 characters.</li> <li><code>%(tag)s</code>: the <code>tag</code> key specified in the recipe.</li> <li><code>%(tag_basename)s</code> if the <code>tag</code> resembles a path, e.g. <code>refs/tags/a/b/c</code>, returns the last part of the path, <code>c</code> in this case.</li> <li><code>%(defaults_upper)s</code>: if building with <code>release</code> defaults, this is the     empty string; else, this is an underscore and then the name defaults,     uppercased, with <code>-</code> replaced by <code>_</code>. For example, if building with     <code>o2-dataflow</code> defaults, <code>%(default_upper)s</code> would be <code>_O2_DATAFLOW</code>.</li> <li><code>%(year)s</code></li> <li><code>%(month)s</code></li> <li><code>%(day)s</code></li> <li><code>%(hour)s</code></li> </ul> <p>Month, day and hour are zero-padded to two digits.</p> </li> </ul> <p>The following entries are optional in the header:</p> <ul> <li> <p><code>source</code>: URL of a Git repository from which the source is downloaded.     It's good practice to make sure that they are already patched, so that you     can easily point to the actual sources used by the software.</p> </li> <li> <p><code>write_repo</code>: in case the repository URL to be used for developing is     different from the <code>source</code>, set this key. It is used by <code>aliBuild init</code>,     which will initialise your local repository with the <code>upstream</code> remote     pointing at this URL instead of the one in <code>source</code>.</p> </li> <li> <p><code>tag</code>: git reference in the above mentioned repository which points to the     software to be built. This can be a tag name, a branch name or a commit     hash.</p> </li> <li> <p><code>env</code>: dictionary whose key-value pairs are environment variables to be set     after the recipe is built. The values are interpreted as the contents of a     double-quoted shell string, so you can reference other environment variables     as <code>$VARIABLE</code>, which will be substituted each time another recipe is built.     For example:</p> <pre><code>env:\n  \"$ROOTSYS\": $ROOT_ROOT\n</code></pre> <p>These variables will not be available in the recipe itself, as they are intended to be used to point to build products of the current recipe. If you need to set an environment variable for use in the recipe, use <code>export VARIABLE=value</code> in the recipe body.</p> </li> <li> <p><code>prepend_path</code>: dictionary whose key-value pairs are an environment variable     name and a path to be prepended to it, as it happens in <code>LD_LIBRARY_PATH</code>.     This happens only after the package declaring the <code>prepend_path</code> in question     is built, so it is not available in the same recipe (just like variables     declared using <code>env</code>). You can append multiple paths to a single variable     by specifying a list too, e.g.:</p> <pre><code>prepend_path:\n  \"PATH\": \"$FOO_ROOT/binexec/foobar\"\n  \"LD_LIBRARY_PATH\": [ \"$FOO_ROOT/sub/lib\", \"$FOO_ROOT/sub/lib64\" ]\n</code></pre> <p>will result in prepending <code>$FOO_ROOT/binexec/foobar</code> to <code>$PATH</code>, and both <code>$FOO_ROOT/sub/lib</code> and <code>lib64</code> to <code>LD_LIBRARY_PATH</code>.</p> </li> <li> <p><code>append_path</code>: same as <code>prepend_path</code> but paths are appended rather than     prepended. Like <code>append_path</code> and <code>env</code>, this does not affect the     environment of the current recipe.</p> </li> <li> <p><code>requires</code>: a list of run-time dependencies for the package, e.g.:</p> <pre><code>package: AliRoot\nrequires:\n  - ROOT\n  ...\n</code></pre> <p>The specified dependencies will be built before building the given package. You can specify platform-specific dependencies by appending <code>:&lt;regexp&gt;</code> to the dependency name. Similarly, you can specify build default specific dependencies by appending <code>:defaults=&lt;regex&gt;</code>.</p> <p>Such a regular expression will be matched against the architecture provided via <code>--architecture</code>, and if it does not match, the requirement will not be included. For instance:</p> <pre><code>package: AliRoot-test\nrequires:\n  - \"igprof:(?!osx).*\"\n</code></pre> <p>will make sure that <code>IgProf</code> is only built on platforms whose name does not begin with <code>osx</code>.</p> </li> <li> <p><code>build_requires</code>: a list of build-time dependencies for the package. Like     <code>requires</code>, these packages will be built before the current package is     built.</p> <p>Packages in this list are marked specially in the dependency graph produced by <code>aliBuild deps</code>. Other tools treat these packages differently from <code>requires</code>: for instance, RPMs produced for a package won't depend on its <code>build_requires</code>, and <code>alibuild-generate-module</code> won't pull in build requirements' modulefiles.</p> </li> <li> <p><code>force_rebuild</code>: set it to <code>true</code> to force re-running the build recipe every     time you invoke alibuild on it.</p> </li> <li> <p><code>prefer_system_check</code>: a script which is used to determine whether     or not the system equivalent of the package can be used. See also     <code>prefer_system</code>. If the <code>--no-system</code> option is specified, this key is not     checked. The shell exit code is used to steer the build: if the check     returns 0, the system package is used and the recipe is not run. If it     returns non-zero, our own version of the package is built through the     recipe.</p> </li> <li> <p><code>prefer_system</code>: a regular expression for architectures which should     use the <code>prefer_system_check</code> by default to determine if the system version     of the tool can be used. When the rule matches, the result of     <code>prefer_system_check</code> determines whether to build the recipe. When the rule     does not match, the check is skipped and the recipe is run. Using the switch     <code>--always-prefer-system</code> runs the check always (even when the regular     expression for the architecture does not match).</p> </li> <li> <p><code>relocate_paths</code>: a list of toplevel paths scanned recursively to perform     relocation of executables and dynamic libraries on macOS only. If not     specified, defaults to <code>bin</code>, <code>lib</code> and <code>lib64</code>.</p> </li> </ul>"},{"location":"reference.html#the-body","title":"The body","text":"<p>This is the build script executed to effectively build and install your software. Being a shell script you can be as flexible as you want in its definition.</p> <p>Some environment variables are made available to the script.</p> <ul> <li><code>INSTALLROOT</code>: the installation prefix. This is commonly passed in the form    <code>./configure --prefix=$INSTALLROOT</code> or    <code>cmake -DCMAKE_INSTALL_PREFIX=$INSTALLROOT</code>. The build tool will create an    archive based on the sole content of this directory.</li> <li><code>PKGNAME</code>: name of the current package.</li> <li><code>PKGVERSION</code>: package version, as defined in the recipe's <code>version:</code> field.</li> <li><code>PKGREVISION</code>: the \"build iteration\", automatically incremented by the build    script.</li> <li><code>PKGHASH</code>: SHA1 checksum of the recipe.</li> <li><code>ARCHITECTURE</code>: an arbitrary string summarizing the current build platform.    This is passed using the <code>--architecture</code> (or <code>-a</code>) argument to the build    script.</li> <li><code>SOURCE0</code>: URL of the source code. Note: if <code>source:</code> is not provided in the    recipe, the variable will be empty.</li> <li><code>GIT_TAG</code>: the Git reference to checkout.</li> <li><code>JOBS</code>: number of parallel jobs to use during compilation. This is passed on    the command line to the build script, and should be used in a context like    <code>make -j$JOBS</code>.</li> <li><code>BUILDDIR</code>: the working directory. This is, e.g., the \"build directory\"    for CMake, i.e. the directory from where you invoke <code>cmake</code>. You should not    write files outside this directory.</li> <li><code>BUILDROOT</code>: it contains <code>BUILDDIR</code> and the log file for the build.</li> <li><code>SOURCEDIR</code>: where the sources are cloned.</li> <li><code>REQUIRES</code>: space-separated list of all dependencies, both runtime and build    only.</li> <li><code>BUILD_REQUIRES</code>: space-separated list of all build dependencies, not needed    at runtime.</li> <li><code>RUNTIME_REQUIRES</code>: space-separated list of all runtime dependencies only.</li> </ul> <p>For each dependency already built, the corresponding environment file is loaded. This will include, apart from custom variables and the usual <code>PATH</code> and library paths, the following specific variables (<code>&lt;PACKAGE&gt;</code> is the package name, uppercased):</p> <ul> <li><code>&lt;PACKAGE&gt;_ROOT</code>: package installation directory.</li> <li><code>&lt;PACKAGE&gt;_VERSION</code>: package version.</li> <li><code>&lt;PACKAGE&gt;_REVISION</code>: package build number.</li> <li><code>&lt;PACKAGE&gt;_HASH</code>: hash of the recipe used to build the package.</li> </ul>"},{"location":"reference.html#defaults","title":"Defaults","text":"<p>aliBuild uses a special file, called <code>defaults-release.sh</code> which will be included as a build requires of any recipe. This is in general handy to specify common options like <code>CXXFLAGS</code> or dependencies. It's up to the recipe handle correctly the presence of these options.</p> <p>It is also possible to specify on the command line a different set of defaults, for example if you want to include code coverage. This is done via the <code>--defaults &lt;default-name&gt;</code> option which will change the defaults included to be <code>defaults-&lt;default-name&gt;.sh</code>.</p> <p>An extra variable <code>%(defaults_upper)s</code> can be used to form the version string accordingly. For example you could trigger a debug build by adding <code>--defaults debug</code>, which will pick up <code>defaults-debug.sh</code>, and then have:</p> <pre><code>version: %(tag)s%(defaults_upper)s\n</code></pre> <p>in one of your recipes, which will expand to:</p> <pre><code>version: SOME_TAG_DEBUG\n</code></pre> <p>If you want to add your own default, you should at least provide:</p> <ul> <li><code>CXXFLAGS</code>: the <code>CXXFLAGS</code> to use</li> <li><code>CFLAGS</code>: the <code>CFLAGS</code> to use</li> <li><code>LDFLAGS</code>: the <code>LDFLAGS</code> to use</li> <li><code>CMAKE_BUILD_TYPE</code>: the build type which needs to be used by cmake projects</li> </ul> <p>Besides specifying extra global variables, starting from aliBuild 1.4.0, it's also possible to use defaults to override metadata of other packages . This is done by specifying the <code>overrides</code> dictionary in the metadata of your defaults file. For example to switch between ROOT6 and ROOT5 you should do something like:</p> <pre><code>...\noverrides:\n  ROOT:\n    version: \"v6-06-04\"\n    tag: \"v6-06-04\"\n...\n</code></pre> <p>this will replace the <code>version</code> and <code>tag</code> metadata of <code>root.sh</code> with the one specified in the override. Notice that is also possible to override completely a recipe, picking it up from a given commit hash, branch or tag in alidist. You can do so by adding such git reference after the name of the external to override. For example:</p> <pre><code>overrides:\n  ROOT@abcedf123456:\n    ...\n</code></pre> <p>will pick <code>root.sh</code> as found in the commit <code>abcedf123456</code>.</p> <p>For a more complete example see defaults-o2.sh.</p> <p>You can limit which defaults can be applied to a given package by using the <code>valid_defaults</code> key.</p>"},{"location":"reference.html#architecture-defaults","title":"Architecture defaults","text":"<p>Architecture defaults are similar to normal defaults but they are always sourced, if available in alidist, and should never be provided on the command line.</p> <p>Their filename is always:</p> <pre><code>defaults-&lt;arch&gt;.sh\n</code></pre> <p>where <code>&lt;arch&gt;</code> is the current architecture. They have precedence over normal defaults.</p>"},{"location":"reference.html#relocation","title":"Relocation","text":"<p>aliBuild supports relocating binary packages so that the scratch space used for builds (e.g. <code>/build</code>) and the actual installation folder (i.e. <code>/cvmfs/alice.cern.ch</code>) do not need to be the same. By design this is done automatically, and the user should not have to care about it. The procedure takes care of relocating scripts and, on macOS, to embed the correct paths for the dynamic libraries dependencies, so that SIP does not need to be disabled. The internal procedure is roughly as follows:</p> <ul> <li>The build happens in <code>BUILD/&lt;package&gt;-latest/&lt;package&gt;</code> and installs   byproducts in   <code>INSTALLROOT=&lt;work-dir&gt;/INSTALLROOT/&lt;package-hash&gt;/&lt;architecture&gt;/&lt;package&gt;/&lt;version&gt;-&lt;revisions&gt;</code>.   This way we know that every file which contains <code>&lt;package-hash&gt;</code> needs to be   relocated.</li> <li>Once the build is completed, aliBuild looks for the above mentioned   <code>&lt;package-hash&gt;</code> and generates a script in the <code>$INSTALLROOT/relocate-me.sh</code>   which can be used to relocate the binary installation, once it has been   unpacked.</li> <li>The path under <code>&lt;work-dir&gt;/INSTALLROOT/&lt;package-hash&gt;</code> is tarred up in a   binary tarball.</li> </ul> <p>When a tarball is installed, either because it was downloaded by aliBuild or by some other script (e.g. the CVMFS publisher, the following happens:</p> <ul> <li>The tarball is expanded.</li> <li>The relocation script <code>relocate-me.sh</code> is executed with something similar to:</li> </ul> <pre><code>WORK_DIR=&lt;new-installation-workdir&gt; relocate-me.sh\n</code></pre> <p>which will take the path up to the <code>&lt;package-hash&gt;</code> and re-map it to the newly   specified <code>WORK_DIR</code>.</p> <p>Notice that the special variable <code>@@PKGREVISION@$PKGHASH@@</code> can be used to have the actual revision of the package in the relocated file.</p>"},{"location":"reference.html#build-environment","title":"Build environment","text":"<p>Before each package is built, aliBuild will populate the environment with build related information. For a complete list of those see the body section. After the build is done the user has access to the environment of the build by sourcing the <code>&lt;work-dir&gt;/&lt;architecture&gt;/&lt;package&gt;/&lt;version&gt;/etc/profile.d/init.sh</code> file. For example:</p> <pre><code>WORK_DIR=&lt;work-dir&gt; source &lt;work-dir&gt;/&lt;architecture&gt;/&lt;package&gt;/&lt;version&gt;/etc/profile.d/init.sh\n</code></pre> <p>Notice that for development packages, we also generate a <code>.envrc</code> file in <code>&lt;work-dir&gt;/BUILD/&lt;package&gt;-&lt;version&gt;/&lt;package&gt;/.envrc</code> which can be used to load the build environment via direnv, e.g. for easy IDE integration.</p>"},{"location":"reference.html#runtime-environment","title":"Runtime environment","text":"<p>Runtime environment is usually provided via environment modules.</p> <p>While the build environment is automatically generated, it is responsibility of the recipe to create a module file in <code>$INSTALLROOT/etc/modulefiles/$PKGNAME</code>. For example:</p> <pre><code># ModuleFile\nmkdir -p etc/modulefiles\ncat &gt; etc/modulefiles/$PKGNAME &lt;&lt;EoF\n#%Module1.0\nproc ModulesHelp { } {\n   global version\n   puts stderr \"ALICE Modulefile for $PKGNAME $PKGVERSION-@@PKGREVISION@$PKGHASH@@\"\n}\nset version $PKGVERSION-@@PKGREVISION@$PKGHASH@@\nmodule-whatis \"ALICE Modulefile for $PKGNAME $PKGVERSION-@@PKGREVISION@$PKGHASH@@\"\n# Dependencies\nmodule load BASE/1.0                                                                      \\\\\n             ${BOOST_REVISION:+boost/$BOOST_VERSION-$BOOST_REVISION}                      \\\\\n             ${FAIRLOGGER_REVISION:+FairLogger/$FAIRLOGGER_VERSION-$FAIRLOGGER_REVISION}  \\\\\n             ${ZEROMQ_REVISION:+ZeroMQ/$ZEROMQ_VERSION-$ZEROMQ_REVISION}                  \\\\\n             ${ASIOFI_REVISION:+asiofi/$ASIOFI_VERSION-$ASIOFI_REVISION}                  \\\\\n             ${DDS_REVISION:+DDS/$DDS_VERSION-$DDS_REVISION}\n# Our environment\nset FAIRMQ_ROOT \\$::env(BASEDIR)/$PKGNAME/\\$version\nprepend-path PATH \\$FAIRMQ_ROOT/bin\nprepend-path LD_LIBRARY_PATH \\$FAIRMQ_ROOT/lib\nEoF\nMODULEDIR=\"$INSTALLROOT/etc/modulefiles\"\nmkdir -p $MODULEDIR &amp;&amp; rsync -a --delete etc/modulefiles/ $MODULEDIR\n</code></pre> <p>Please keep in mind the following recommendation when writing the modulefile:</p> <ul> <li>Do not use runtime environment variables which are usually not set by a given   tool. For example avoid exposing <code>&lt;package&gt;_ROOT</code>. This is because if we build   in a mode where system dependencies are used, we cannot rely on their   presence.</li> <li>Use <code>&lt;package&gt;_REVISION</code> to guard inclusion of extra dependencies. This will   make sure that only dependencies which were actually built via <code>aliBuild</code> will   be included in the modulefile.</li> </ul> <p>It's also now possible to generate automatically the initial part of the modulefile, up to the <code># Our environment</code> line, by using the <code>alibuild-recipe-tools</code> helper scripts. In order to do this you need to add <code>alibuild-recipe-tools</code> as a <code>build_requires</code> of your package and substitute the module creation with:</p> <pre><code>#ModuleFile\nmkdir -p etc/modulefiles\nalibuild-generate-module &gt; etc/modulefiles/$PKGNAME\nmkdir -p $INSTALLROOT/etc/modulefiles &amp;&amp; rsync -a --delete etc/modulefiles/ $INSTALLROOT/etc/modulefiles\n</code></pre> <p>One can also make sure that <code>PATH</code> and <code>LD_LIBRARY_PATH</code> are properly amended by passing the option <code>--bin</code> and <code>--lib</code> (respectively). Or you can simply append extra information via:</p> <pre><code>alibuild-generate-module &gt; etc/modulefiles/$PKGNAME\ncat &gt;&gt; etc/modulefiles/$PKGNAME &lt;&lt;EoF\nprepend-path ROOT_INCLUDE_PATH \\$PKG_ROOT/include\nEoF\n</code></pre>"},{"location":"troubleshooting.html","title":"Troubleshooting","text":"<p>In case build fails you can find per-build log files under the <code>BUILD</code> directory located in the working directory.</p> <p>Assuming the working directory is <code>sw</code> (the default) and the package whose build failed is <code>boost</code>, you will find its log under:</p> <pre><code>sw/BUILD/boost-latest/log\n</code></pre> <p>Note that when running <code>aliBuild --debug</code> the output is also echoed in your current terminal.</p>"},{"location":"troubleshooting.html#common-issues","title":"Common issues","text":""},{"location":"troubleshooting.html#i-have-an-error-while-compiling-aliphysics-aliroot","title":"I have an error while compiling AliPhysics / AliRoot.","text":"<p>Notice that in general this kind of errors are not really aliBuild related, but they are genuine issues in either AliRoot and AliPhysics. To get the accurate and fastest feedback, the \"best practice\" is to do the following:</p> <ul> <li>Make sure you have the latest version of both AliPhysics and AliRoot. If   not, update to it and rebuild. Most likely someone else has already noticed   your problem and fixed it. aliBuild will actually remind you of doing so if   you are using master.</li> <li>If you still have a message, read what the error log for your package   is saying and try to extract the first error. In general you can simply   look for the first occurrence of <code>***</code> or <code>error:</code> and try to read a few   lines around there.</li> <li> <p>Try to find out who modified the files with an error last. This can be done by   cd-ing into <code>AliRoot</code> / <code>AliPhysics</code>, issuing:</p> <p>git log @{yesterday}.. --  <p>and reading who was the author of the last few commits. - Write a message to <code>alice-project-analysis-task-force@cern.ch</code>   explaining the error. Make sure you report the first few lines of it you   have identified above, and to include the author of the last changes in   the problematic file. - Make sure you do not attach big log files since they will cause a   traffic storm since the list has many participants and each one of them   will get a copy of the attachment, even if not interested. A much better   approach is to use a service like CERNBox,   Dropbox or alikes which allow to share files by providing a link to them,   rather than by attachment.</p>"},{"location":"troubleshooting.html#what-are-the-system-prerequisites-of-alibuild","title":"What are the system prerequisites of alibuild?","text":"<p>In principle aliBuild should now notify you for missing required system dependencies and complain with a clear message if that is not the case. For example if you lack bz2 it will now tell you with the following message:</p> <pre><code>Please install bzip2 development package on your system\n</code></pre> <p>Moreover it will try to reuse as much as possible from your system, so if you have a system CMake which is compatible with the one required by AliRoot it will also pick up your version. Failing that it will build it for you. You can have a look at what AliRoot will do by adding the <code>--dry-run</code> option to your build command, e.g.:</p> <pre><code>alibuild --dry-run &lt;additional options you might have&gt; build AliRoot\n</code></pre> <p>will tell you something like:</p> <pre><code>Using package CMake from the system as preferred choice.\nUsing package libxml2 from the system as preferred choice.\nUsing package SWIG from the system as preferred choice.\nUsing package zlib from the system as preferred choice.\nUsing package autotools from the system as preferred choice.\nUsing package GSL from the system as preferred choice.\nSystem package boost cannot be used. Building our own copy.\nWe will build packages in the following order: defaults-release AliEn-CAs GMP UUID gSOAP ApMon-CPP GEANT4 boost MPFR MonALISA-gSOAP-client cgal XRootD fastjet xalienfs AliEn-Runtime ROOT vgm GEANT3 GEANT4_VMC AliRoot\n</code></pre> <p>If you have a system package which you think should be used but it's not, you can run <code>aliBuild doctor &lt;package-name&gt;</code> to try to understand why that was the case (or you can open a bug report with its output and we will look at it).</p>"},{"location":"troubleshooting.html#what-is-pip-how-do-i-install-it","title":"What is PIP ? How do I install it?","text":"<p>PIP is the de-facto standard package manager for python. While it is usually installed by default on modern distributions, it can happen this is not the case. If so, you can usually get it via:</p> <pre><code>sudo yum install python-pip     # (Centos / Fedora / SLC derivatives)\nsudo dnf install python-pip     # (Fedora 22+)\nsudo apt-get install python-pip # (Ubuntu / Debian alikes)\n</code></pre> <p>Alternatively you can try to install it by hand by following the instructions here.</p>"},{"location":"troubleshooting.html#package-branch-was-updated-but-alibuild-does-not-rebuild-it","title":"Package branch was updated, but aliBuild does not rebuild it","text":"<p>Some recipes specify branches in the <code>tag:</code> field instead of an actual tag. For such recipes, aliBuild must contact remote servers in order to determine what is the latest commit for that branch. Since this is a corner case and the operation is expensive and slow, it is off by default, and cached information is used instead. Try to ask aliBuild to update its cached information by using the <code>-u</code> or <code>--fetch-repos</code> switch.</p>"},{"location":"troubleshooting.html#alien-broken-after-building-with-alibuild","title":"AliEn broken after building with aliBuild","text":"<p>If you are migrating from other ALICE build instructions to use aliBuild and you are running on OSX, it could happen that you encounter an error of the kind:</p> <pre><code>dlopen error: dlopen(/Users/me/alice/sw/osx_x86-64/ROOT/v5-34-30-alice-1/lib/libNetx.so, 9): Library not loaded: libXrdUtils.1.dylib\n  Referenced from: /Users/me/alice/sw/osx_x86-64/ROOT/v5-34-30-alice-1/lib/libNetx.so\n  Reason: image not found\nLoad Error: Failed to load Dynamic link library /Users/me/alice/sw/osx_x86-64/ROOT/v5-34-30-alice-1/lib/libNetx.so\nE-TCint::AutoLoadCallback: failure loading dependent library libNetx.so for class TAlienJDL\ndlopen error: dlopen(/Users/me/alice/sw/osx_x86-64/ROOT/v5-34-30-alice-1/lib/libRAliEn.so, 9): Library not loaded: /Users/jmargutti/alice/sw/INSTALLROOT/ac18e6eaa3ed801ac1cd1e788ac08c82ffd29235/osx_x86-64/xalienfs/v1.0.14r1-1/lib/libgapiUI.4.so\n  Referenced from: /Users/me/alice/sw/osx_x86-64/ROOT/v5-34-30-alice-1/lib/libRAliEn.so\n  Reason: image not found\nLoad Error: Failed to load Dynamic link library /Users/me/alice/sw/osx_x86-64/ROOT/v5-34-30-alice-1/lib/libRAliEn.so\nE-TCint::AutoLoadCallback: failure loading library libRAliEn.so for class TAlienJDL\ndlopen error: dlopen(/Users/me/alice/sw/osx_x86-64/AliEn-Runtime/v2-19-le-1/lib/libgapiUI.so, 9): Library not loaded: libXrdSec.0.dylib\n  Referenced from: /Users/me/alice/sw/osx_x86-64/AliEn-Runtime/v2-19-le-1/lib/libgapiUI.so\n  Reason: image not found\nLoad Error: Failed to load Dynamic link library /Users/me/alice/sw/osx_x86-64/AliEn-Runtime/v2-19-le-1/lib/libgapiUI.so\nE-P010_TAlien: Please fix your loader path environment variable to be able to load libRAliEn.so\n</code></pre> <p>This happens because the new version of AliEn compiled by aliBuild is incompatible with the old one. You can fix this issue by doing:</p> <ol> <li>Remove old alien token stuff from <code>/tmp</code> (e.g. <code>rm /tmp/gclient_env* /tmp/gclient_token* /tmp/x509*</code>)</li> <li>Get a new token</li> <li>Source <code>/tmp/gclient_env*</code> file</li> </ol> <p>and trying again.</p>"},{"location":"troubleshooting.html#alibuild-does-not-work-on-osx-with-python-shipped-with-anaconda","title":"aliBuild does not work on OSX with Python shipped with ANACONDA","text":"<p>If you are using ANACONDA (<code>which python</code> to verify), the old version of aliBuild had troubles with it. Upgrading to the latest version via:</p> <pre><code>pip install --upgrade alibuild\n</code></pre> <p>or by doing <code>git pull</code> should fix the issue.</p>"},{"location":"troubleshooting.html#alibuild-does-not-pick-up-tool-x-from-the-system","title":"aliBuild does not pick up tool X from the system","text":"<p>By default aliBuild prefers using tools from the system whenever possible. Examples of those tools are CMake, the GCC compiler or the autotools suite. If this does not happen even if you have it installed it means that aliBuild does not consider you system tool good enough to be compatible with the one provided by the recipe. You can verify what happens during the system tool detection by running:</p> <pre><code>aliBuild doctor &lt;package name&gt;\n</code></pre>"},{"location":"troubleshooting.html#alibuild-fails-with-cannot-open-file-availabilitymacrosh","title":"AliBuild fails with <code>cannot open file \"AvailabilityMacros.h</code>","text":"<p>If your build fails with:</p> <pre><code>Error: cannot open file \"AvailabilityMacros.h\" sw/BUILD/.../ROOT/include/RConfig.h:384:\n</code></pre> <p>and you are on macOS, this most likely means you have an incomplete XCode installation, e.g. due to an upgrade. You can fix this with:</p> <pre><code>xcode-select --install\n</code></pre>"},{"location":"troubleshooting.html#i-do-not-have-privileges-and-i-cannot-install-via-pip","title":"I do not have privileges and I cannot install via pip","text":"<p>If you do not have root privileges on your machine and <code>pip install alibuild</code> fails, you have two options:</p> <ul> <li> <p>If your pip supports it, you can add the <code>--user</code> flag and that will install   alibuild in <code>~/.local</code>. I.e.:</p> <p>pip install --user alibuild</p> </li> <li> <p>If your pip is old or if you do not have pip at all on your system or   you do not want to use pip for whatever reasons, you can still simply   checkout the sources with:</p> <p>git clone https://github.com/alisw/alibuild</p> </li> </ul> <p>and simply run alibuild by invoking <code>alibuild/aliBuild</code>.</p>"},{"location":"troubleshooting.html#i-am-changing-an-uncommitted-file-in-a-development-package-but-it-is-not-updated-in-the-installation-folder","title":"I am changing an uncommitted file in a development package, but it is not updated in the installation folder.","text":"<p>If you add a file to a development package and the build recipe is able to handle uncommitted files, it will be copied the first time.</p> <p>However alibuild considers any untracked file as the same, and therefore unless the file is added or committed to the local clone of the development package any subsequent rebuild will ignore the changes. This can be worked around in two ways:</p> <ol> <li>You add the file to your local clone via git add / git commit</li> <li>You add an incremental_recipe which is able to handle uncommitted files</li> </ol> <p>What 1. does is to make alibuild aware of the changes of the new file, so you will get a new build for each change to the file. What 2. does is to always execute the incremental recipe to refresh the installation folder on each aliBuild invocation, possibly updating untracked files if so specified in the recipe itself.</p>"},{"location":"troubleshooting.html#how-do-i-set-compilation-options-for-aliroot-and-or-aliphysics","title":"How do I set compilation options for AliRoot and / or AliPhysics?","text":"<p>If you want to change the compilation options for AliRoot, AliPhysics, or as a matter of fact any packages you have two options:</p> <ul> <li>If the package itself is one which you are developing locally, i.e.   you have the checkout available, you can modify its CMakeFile, add   whatever options you like there and then issue again your aliBuild   command.</li> <li>On contrary, if you do not have a local checkout but you still want to   modify it's compiler flags, you can edit the <code>alidist/aliroot.sh</code> recipe   and add the options there.</li> </ul> <p>Finally, for certain common options, e.g. debug flags, we provide a precooked configuration using so called defaults. Simply add <code>--defaults debug</code> to your aliBuild flags and it will add debug flags to all your packages.</p>"},{"location":"troubleshooting.html#aliphysics-takes-very-long-time-to-build-and-builds-things-like-autotools-gcc","title":"AliPhysics takes very long time to build and builds things like autotools, GCC","text":"<p>In order to build AliPhysics, a number of externals are required, including working autotools, boost, and GCC. While aliBuild tries it best to reuse whatever comes from the system, it will not complain when building unless one of the system dependencies is absolutely required (e.g. X11, perl). This might lead to the fact it will rebuild large tool, where simply installing them might be a better option. For this reason we suggest that users run:</p> <pre><code>aliBuild doctor AliPhysics\n</code></pre> <p>in the same path where their <code>alidist</code> folder is, before actually starting to build, so that they can get an overview of what will be picked up from the system and what not.</p> <p>Notice that if you change (either add or remove) your set of system dependencies, aliBuild will trigger a rebuild of whatever depends on them, taking additional time, so make sure you do this when not pressed for a deadline.</p>"},{"location":"troubleshooting.html#permission-denied-when-running-alienv-on-shared-farm-installations","title":"Permission denied when running alienv on shared (farm) installations","text":"<p>When attempting to do <code>alienv</code> operations on shared (farm) installations you might get a number of <code>Permission denied</code> errors. In order to fix this problem you need to make sure that shared builds with <code>aliBuild</code> are always made by the same user. In addition after every <code>aliBuild</code> run the person who has run it has to run the following command in order to generate all the correct modulefiles as seen by the users:</p> <pre><code>alienv q\n</code></pre> <p>Users have to append the <code>--no-refresh</code> option to every <code>alienv</code> operation, for instance:</p> <pre><code>alienv --no-refresh enter AliPhysics/latest\n</code></pre> <p>Note that the <code>--no-refresh</code> option is not necessary anymore starting from <code>v1.4.0.rc1</code>.</p>"},{"location":"troubleshooting.html#building-on-windows-ubuntu-environment-does-not-work","title":"Building on Windows Ubuntu environment does not work","text":"<p>At the time of writing, neither Windows native nor the Ubuntu environment  on Windows are supported and most likely this will stay the same unless some third party does the work and provides a pull request.</p>"},{"location":"troubleshooting.html#can-i-build-on-an-unsupported-architecture","title":"Can I build on an unsupported architecture?","text":"<p>You can try, but of course your mileage might vary. In case the architecture is similar to one of the supported ones (e.g. Ubuntu and Kubuntu) this should be recognized automatically and the build should proceed, attempting to use the supported one. This will still not guarantee things will not break for some packages.</p> <p>In case the architecture is completely unknown to us, you will get a message:</p> <pre><code>ERROR: Cannot autodetect architecture\n</code></pre> <p>if you still want to try, you can use the <code>--force-unknown-architecture</code> option and while we strive our best to help you out also in this case, sometimes priorities force us to simply ignore support requests.</p>"},{"location":"troubleshooting.html#how-do-i-run-on-a-system-where-i-do-not-have-global-install-rights","title":"How do I run on a system where I do not have global install rights?","text":"<p>If you want to run on a system where you do not have global install rights, and the PyYAML package is not installed (e.g. lxplus), you can still do so by using the <code>--user</code> flag when you install with <code>pip</code>. This will install alibuild under <code>~/.local/bin</code>.</p> <p>This means that you need to do (only once):</p> <pre><code>pip install --user --upgrade alibuild\n</code></pre> <p>and then adapt you PATH to pickup the local installation, e.g. via:</p> <pre><code>export PATH=~/.local/bin:$PATH\n</code></pre>"},{"location":"troubleshooting.html#alibuild-keeps-asking-for-my-password","title":"aliBuild keeps asking for my password","text":"<p>Some packages you may need to build have their source code in a protected repository on CERN GitLab. This means that you may be asked for a username and password when you run <code>aliBuild build</code>. See below for ways to avoid being prompted too often.</p>"},{"location":"troubleshooting.html#ssh-authentication","title":"SSH authentication","text":"<p>You can use an SSH key to authenticate with CERN GitLab. This way, you will not be prompted for your GitLab password at all. To do this, find your public key (this usually lives in <code>~/.ssh/id_rsa.pub</code>) and copy the contents of the file into your user settings on CERN GitLab. If you have no SSH key, you can generate one using the <code>ssh-keygen</code> command. Then, configure git to use SSH to authenticate with CERN GitLab using the following command:</p> <pre><code>git config --global 'url.ssh://git@gitlab.cern.ch:7999/.insteadof' 'https://gitlab.cern.ch/'\n</code></pre>"},{"location":"troubleshooting.html#caching-passwords","title":"Caching passwords","text":"<p>If you prefer not to use SSH keys as described above, you can alternatively configure git to remember the passwords you input for a short time (such as a few hours). In order to do this, run the command below (which remembers your passwords for an hour each time you type them into git).</p> <pre><code>git config --global credential.helper 'cache --timeout 3600'\n</code></pre> <p>You can adjust the timeout (3600 seconds, above) to your liking, if you would prefer git to remember your passwords for longer.</p>"},{"location":"troubleshooting.html#i-get-an-http2-related-error","title":"I get an HTTP/2 related error","text":"<p>Some network provider do not support HTTP/2 apparently. If you get:</p> <pre><code>error: RPC failed; curl 92 HTTP/2 stream 5 was not closed cleanly: CANCEL (err 8)\n</code></pre> <p>or similar message, try to disable HTTP/2 with something like:</p> <pre><code>git config --global http.version HTTP/1.1\n</code></pre>"},{"location":"user.html","title":"User manual","text":""},{"location":"user.html#synopsis","title":"SYNOPSIS","text":"<p>For a quick start introduction, please look here.</p> <pre><code>aliBuild build [-h] [--defaults DEFAULT]\n               [-a ARCH] [--force-unknown-architecture]\n               [-z [DEVELPREFIX]] [-e ENVIRONMENT] [-j JOBS] [-u]\n               [--no-local PKGLIST] [--force-tracked] [--disable PACKAGE]\n               [--force-rebuild PACKAGE] [--annotate PACKAGE=COMMENT]\n               [--only-deps] [--plugin PLUGIN]\n               [--always-prefer-system | --no-system]\n               [--docker] [--docker-image IMAGE] [--docker-extra-args ARGLIST] [-v VOLUMES]\n               [--no-remote-store] [--remote-store STORE] [--write-store STORE] [--insecure] \n               [-C DIR] [-w WORKDIR] [-c CONFIGDIR] [--reference-sources MIRRORDIR]\n               [--aggressive-cleanup] [--no-auto-cleanup]\n               PACKAGE [PACKAGE ...]\n</code></pre> <ul> <li><code>PACKAGE</code>: One of the packages in <code>CONFIGDIR</code>. May be specified multiple   times.</li> <li><code>-h</code>, <code>--help</code>: show this help message and exit</li> <li><code>--defaults DEFAULT</code>: Use defaults from <code>CONFIGDIR/defaults-DEFAULT.sh</code>.</li> <li><code>-a ARCH</code>, <code>--architecture ARCH</code>: Build as if on the specified architecture.   When used with <code>--docker</code>, build inside a Docker image for the specified   architecture. Default is the current system architecture.</li> <li><code>--force-unknown-architecture</code>: Build on this system, even if it doesn't have   a supported architecture.</li> <li><code>-z [DEVELPREFIX]</code>, <code>--devel-prefix [DEVELPREFIX]</code>: Version name to use for   development packages. Defaults to branch name.</li> <li><code>-e ENVIRONMENT</code>: KEY=VALUE binding to add to the build environment. May be   specified multiple times.</li> <li><code>-j JOBS</code>, <code>--jobs JOBS</code>: The number of parallel compilation processes to run.</li> <li><code>-u</code>, <code>--fetch-repos</code>: Fetch updates to repositories in <code>MIRRORDIR</code>. Required   but nonexistent repositories are always cloned, even if this option is not   given.</li> <li><code>--no-local PKGLIST</code>: Do not pick up the following packages from a local   checkout. <code>PKGLIST</code> is a comma-separated list.</li> <li><code>--force-tracked</code>: Do not pick up any packages from a local checkout.</li> <li><code>--disable PACKAGE</code>: Do not build <code>PACKAGE</code> and all its (unique) dependencies.</li> <li><code>--force-rebuild PACKAGE</code>: Always rebuild the specified packages from scratch,   even if they were built before. Has the same effect as adding   <code>force_rebuild: true</code> to the recipe. May be specified multiple times or   separate multiple arguments with commas.</li> <li><code>--annotate PACKAGE=COMMENT</code>: Store <code>COMMENT</code> in the build metadata for   <code>PACKAGE</code>. The comment will only be stored if the package is compiled or   downloaded during this run. May be specified multiple times.</li> <li><code>--only-deps</code>: Only build dependencies, not the main package. Useful for   populating a build cache.</li> <li><code>--plugin PLUGIN</code>: Plugin to use for the build. Default is <code>legacy</code>.</li> <li><code>--always-prefer-system</code>: Always use system packages when compatible.</li> <li><code>--no-system</code>: Never use system packages, even if compatible.</li> </ul>"},{"location":"user.html#building-inside-a-container","title":"Building inside a container","text":"<p>Builds can be done inside a Docker container, to make it easier to get a common, usable environment. The Docker daemon must be installed and running on your system. By default, images from <code>alisw/&lt;platform&gt;-builder:latest</code> will be used, e.g. <code>alisw/slc8-builder:latest</code>. They will be fetched if unavailable.</p> <ul> <li><code>--docker</code>: Build inside a Docker container.</li> <li><code>--docker-image IMAGE</code>: The Docker image to build inside of. Implies   <code>--docker</code>. By default, an image is chosen based on the architecture.</li> <li><code>--docker-extra-args ARGLIST</code>: Command-line arguments to pass to <code>docker run</code>.   Passed through verbatim -- separate multiple arguments with spaces, and make   sure quoting is correct! Implies <code>--docker</code>.</li> <li><code>-v VOLUMES</code>: Additional volume to be mounted inside the Docker container, if   one is used. May be specified multiple times. Passed verbatim to <code>docker run</code>.</li> </ul>"},{"location":"user.html#re-using-prebuilt-tarballs","title":"Re-using prebuilt tarballs","text":"<p>Reusing prebuilt tarballs saves compilation time, as common packages need not be rebuilt from scratch. <code>rsync://</code>, <code>https://</code>, <code>b3://</code> and <code>s3://</code> remote stores are recognised. Some of these require credentials: <code>s3://</code> remotes require an <code>~/.s3cfg</code>; <code>b3://</code> remotes require <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables. A useful remote store is <code>https://s3.cern.ch/swift/v1/alibuild-repo</code>. It requires no credentials and provides tarballs for the most common supported architectures.</p> <ul> <li><code>--no-remote-store</code>: Disable the use of the remote store, even if it is   enabled by default.</li> <li><code>--remote-store STORE</code>: Where to find prebuilt tarballs to reuse. See above   for available remote stores. End with <code>::rw</code> if you want to upload (in that   case, <code>::rw</code> is stripped and <code>--write-store</code> is set to the same value).   Implies <code>--no-system</code>. May be set to a default store on some architectures;   use <code>--no-remote-store</code> to disable it in that case.</li> <li><code>--write-store STORE</code>: Where to upload newly built packages. Same syntax as   <code>--remote-store</code>, except <code>::rw</code> is not recognised. Implies <code>--no-system</code>.</li> <li><code>--insecure</code>: Don't validate TLS certificates when connecting to an <code>https://</code>   remote store.</li> </ul>"},{"location":"user.html#customise-alibuild-directories","title":"Customise aliBuild directories","text":"<ul> <li><code>-C DIR</code>, <code>--chdir DIR</code>: Change to the specified directory before building.   Alternatively, set <code>ALIBUILD_CHDIR</code>. Default <code>.</code>.</li> <li><code>-w WORKDIR</code>, <code>--work-dir WORKDIR</code> The toplevel directory under which builds   should be done and build results should be installed. Default <code>sw</code>.</li> <li><code>-c CONFIGDIR</code>, <code>--config-dir CONFIGDIR</code>: The directory containing build   recipes. Default <code>alidist</code>.</li> <li><code>--reference-sources MIRRORDIR</code>: The directory where reference git   repositories will be cloned. <code>%(workDir)s</code> will be substituted by <code>WORKDIR</code>.   Default <code>%(workDir)s/MIRROR</code>.</li> </ul>"},{"location":"user.html#cleaning-up-after-building","title":"Cleaning up after building","text":"<ul> <li><code>--aggressive-cleanup</code>: Delete as much build data as possible when cleaning   up.</li> <li><code>--no-auto-cleanup</code>: Do not clean up build directories automatically after a   build.</li> </ul>"},{"location":"user.html#using-precompiled-packages","title":"Using precompiled packages","text":"<p>By running aliBuild with no special option on CentOS/Alma 7, 8 or 9 (x86-64 or ARM), or on Ubuntu 20.04, 22.04 or 24.04 (x86-64), it will automatically try to use as many precompiled packages as possible by downloading them from a default central server. By using precompiled packages you lose the ability to pick some of them from your system. If you do not want to use precompiled packages and you want to pick as many packages as possible from your system, you should manually specify the <code>--always-prefer-system</code> option.</p> <p>It is possible to benefit from precompiled builds on every platform, provided that the server caching the builds is maintained by yourself. Since every build is stored as a tarball with a unique hash, it is sufficient to provide for a server or shared space where cached builds will be stored and made available to others.</p> <p>In order to specify the cache store, use the option <code>--remote-store &lt;uri&gt;</code>, where <code>&lt;uri&gt;</code> can be:</p> <ul> <li>a local path, for instance <code>/opt/alibuild_cache</code>,</li> <li>a remote SSH accessible path, <code>ssh://&lt;host&gt;:&lt;path&gt;</code>,</li> <li>an unencrypted rsync path, <code>rsync://&lt;host&gt;/path</code>,</li> <li>a CERN S3 bucket, <code>b3://&lt;bucket&gt;</code>,</li> <li>a HTTP(s) server, <code>http://&lt;host&gt;/&lt;path&gt;</code>.</li> </ul> <p>The first four options can also be writable (if you have proper permissions): if you specify <code>::rw</code> at the end of the URL, your builds will be cached there. This is normally what sysadmins do to precache builds: other users can simply use the same URL in read-only mode (no <code>::rw</code> specified) to fetch the builds.</p> <p>You need to make sure you have proper filesystem/SSH/rsync permissions of course.</p> <p>It is also possible to specify a write store different from the read one by using the <code>--write-store</code> option.</p> <p>aliBuild can reuse precompiled packages if they were built with a different tag, if that tag points to the same actual commit that you're building now. (This is used for the nightly tags, as they are built from a branch named <code>rc/nightly-YYYYMMDD</code>, while alidist is updated to have a tag like <code>nightly-YYYYMMDD</code> instead, pointing to the same commit.) However, this reuse only works if the precompiled package has the same version as specified in your copy of alidist.</p> <p>This approach assumes that tags don't move (i.e. don't change which commit they are tagging) in the repositories being built. If you administer a cache store, make sure to delete cached tarballs built using that tag if a tag is moved!</p>"},{"location":"user.html#developing-packages-locally","title":"Developing packages locally","text":"<p>One of the use cases we want to cover is the ability to develop external packages without having to go through an commit - push - pull cycle.</p> <p>In order to do so, you can simply checkout the package you want to develop at the same level as alibuild and alidist.</p> <p>For example, if you want to build O2 while having the ability to modify ROOT, you can do the following:</p> <pre><code>git clone https://github.com/alisw/alidist\ngit clone https://github.com/root-mirror/root ROOT\n&lt;modify files in ROOT/&gt;\naliBuild ... build O2\n</code></pre> <p>The above will make sure the build will pick up your changes in the local directory.</p> <p>As a cherry on the cake, in case your recipe does not require any environment, you can even do:</p> <pre><code>cd sw/BUILD/ROOT/latest\nmake install\n</code></pre> <p>and it will correctly install everything in <code>sw/&lt;arch&gt;/ROOT/latest</code>. This of course mean that for each development package you might end up with one or more build directories which might increase the used disk space.</p> <p>It's also important to notice that if you use your own checkout of a package, you will not be able to write to any store and the generated tgz will be empty.</p> <p>If you wish to temporary compile with the package as specified by alidist, you can use the <code>--no-local &lt;PACKAGE&gt;</code> option.</p>"},{"location":"user.html#incremental-builds","title":"Incremental builds","text":"<p>When developing locally using the development mode, if the external is well behaved and supports incremental building, it is possible to specify an <code>incremental_recipe</code> in the YAML preamble. Such a recipe will be used after the second time the build happens (to ensure that the non incremental parts of the build are done) and will be executed directly in $BUILDDIR, only recompiled what changed. Notice that if this is the case the incremental recipe will always be executed.</p>"},{"location":"user.html#forcing-a-different-architecture","title":"Forcing a different architecture","text":"<p>While alibuild does its best to find out which OS / distribution you are using, sometimes it might fail to do so, for example in the case you start using a new *buntu flavour or a bleeding edge version of a distribution. In order to force the correct architecture for the build you can use the <code>--architecture</code> (<code>-a</code>) flag with one of the supported options:</p> <p>On Linux, x86-64: - <code>slc6_x86-64</code>: RHEL6 / SLC6 compatible - <code>slc7_x86-64</code>: RHEL7 / CC7 compatible - <code>slc8_x86-64</code>: RHEL8 / CC8 compatible - <code>slc9_x86-64</code>: RHEL9 / ALMA9 compatible - <code>ubuntu2004_x86-64</code>: Ubuntu 20.04 compatible - <code>ubuntu2204_x86-64</code>: Ubuntu 22.04 compatible - <code>ubuntu2404_x86-64</code>: Ubuntu 24.04 compatible - <code>fedora33_x86-64</code>: Fedora 33 compatible - <code>fedora34_x86-64</code>: Fedora 34 compatible</p> <p>On Linux, ARM: - <code>slc9_aarch64</code>: RHEL9 / ALMA9 compatible</p> <p>On Linux, POWER8 / PPC64 (little endian): - <code>slc7_ppc64</code>: RHEL7 / CC7 compatible</p> <p>On Mac: - <code>osx_x86-64</code>: Intel - <code>osx_arm64</code>: Apple Silicon</p>"},{"location":"user.html#running-in-docker","title":"Running in Docker","text":"<p>Very often one needs to run on a platform which is different from the one being used for development. The common use case is that development happens on a Mac while production runs on some older Linux distribution like SLC5 or SLC6. In order to improve the experience of cross platform development aliBuild now offers the ability to run in Docker via the <code>--docker</code> option. When it is specified the first part of the architecture will be used to construct the name of the docker container to be used for the build and the build itself will be performed inside that container. For example if you specify:</p> <pre><code>alibuild --docker -a slc7_x86-64 build ROOT\n</code></pre> <p>the build itself will happen inside the alisw/slc7-builder Docker container. Environment variables can be passed to docker by specifying them with the <code>-e</code> option. Extra volumes can be specified with the -v option using the same syntax used by Docker.</p>"},{"location":"user.html#defaults","title":"Defaults","text":"<p>By default, <code>aliBuild</code> uses the <code>o2</code> defaults (<code>--defaults o2</code>), which are optimized for building the ALICE O2 software stack. The defaults system allows you to specify different sets of build configurations, compiler flags, and package versions through the <code>--defaults</code> option.</p> <p>Different defaults can be used to: - Use different package versions (e.g., different ROOT versions) - Apply specific compiler flags (e.g., debug builds, optimization levels) - Enable or disable certain features or packages</p> <p>To use a different set of defaults, use the <code>--defaults &lt;name&gt;</code> option, which will load settings from <code>CONFIGDIR/defaults-&lt;name&gt;.sh</code>. For example, <code>--defaults o2-epn</code> would use the <code>defaults-o2-epn.sh</code> file.</p> <p>For a more complete description of how the defaults system works and how to create custom defaults, please look at the reference manual.</p>"},{"location":"user.html#disabling-packages","title":"Disabling packages","text":"<p>You can optionally disable certain packages by specifying them as a comma separated list with the <code>--disable</code> option.</p> <p>It's also possible to disable packages by adding them to the <code>disable</code> keyword of your defaults file (see previous paragraph). See the defaults-o2.sh file for an example of how to disable <code>mesos</code> and <code>MySQL</code> when passing <code>--defaults o2</code>.</p>"},{"location":"user.html#controlling-which-system-packages-are-picked-up","title":"Controlling which system packages are picked up","text":"<p>When compiling, there is a number of packages which can be picked up from the system, and only if they are not found, do not have their devel part installed, or they are not considered good enough they are recompiled from scratch. A typical example is things like autotools, zlib or cmake which should be available on a standard developer machine and we rebuild them as last resort. In certain cases, to ensure full compatibility on what is done in production it might be desirable to always pick up our own version of the tools. This can be done by passing the <code>--no-system</code> option to alibuild. On the other hand, there might be cases in which you want to pick up not only basic tools, but also advanced ones like ROOT, Geant4, or Pythia from the system, either to save time or because you have a pre-existing setup which you do not want to touch. In this case you can use <code>--always-prefer-system</code> option which will try very hard to reuse as many system packages as possible (always checking they are actually compatible with the one used in the recipe).</p>"},{"location":"user.html#cleaning-up-the-build-area-new-in-110","title":"Cleaning up the build area (new in 1.1.0)","text":"<p>Whenever you build using a different recipe or set of sources, alibuild makes sure that all the dependent packages which might be affected by the change are rebuild, and it does so in a different directory. This can lead to the profiliferation of many build / installation directories, in particular while developing a recipe for a new package (e.g. a new generator).</p> <p>In order to remove all past builds and only keep the latest one for each alidist area you might have used and for each breanch (but not commit) ever build for a given development package you can use the</p> <pre><code>aliBuild clean\n</code></pre> <p>subcommand which will do its best to clean up your build and installation area.</p>"},{"location":"user.html#upgrading-alibuild","title":"Upgrading aliBuild","text":"<p>aliBuild can be installed either via <code>pip</code>, or by your OS package manager (more info here. </p> <p>The way to upgrade it depends on your installation method. If you installed it via <code>pip</code>, you can upgrade it by running:</p> <pre><code>pip install --upgrade alibuild\n</code></pre> <p>In general updating aliBuild is safe and it should never trigger a rebuild or break compilation of older versions of alidist (i.e. we do try to guarantee backward compatibility). In no case an update of aliBuild will result in the update of <code>alidist</code>, which users will have to be done separately. In case some yet to appear bug in alibuild will force us to rebuild a previously built area, this will be widely publicized and users will get a warning when running the command.</p> <p>You can also upgrade / install a specific version of alibuild by specifying it on the  command line. E.g.:</p> <pre><code>pip install alibuild=1.17.23\n</code></pre>"},{"location":"user.html#rebuilding-packages-from-branches-instead-of-tags","title":"Rebuilding packages from branches instead of tags","text":"<p>Generally, recipes specify a Git tag name in the <code>tag:</code> field. In some cases, branch names might be used instead (such as <code>tag: master</code> or <code>tag: dev</code>). In such a rare case, aliBuild needs to know what is the last branch commit to determine whether a rebuild is necessary.</p> <p>Such check by default uses cached information instead of doing very slow queries to remote servers. This means that aliBuild is fast in determining which packages to build. However, packages using branch names might not get rebuilt as expected when new changes are pushed to those branches.</p> <p>In this case, you can ask aliBuild to update cached branches information by adding the <code>-u</code> or <code>--fetch-repos</code> option. Note that by default this is not needed, it's only for very special use cases (such as centralized builds and server-side pull request checks).</p>"},{"location":"user.html#generating-a-dependency-graph","title":"Generating a dependency graph","text":"<p>It is possible to generating a PDF with a dependency graph using the <code>aliBuild deps</code> tool. Assuming you run it from a directory containing <code>alidist</code>, and you have Graphviz installed on your system, you can simply run:</p> <pre><code>aliBuild deps O2 --outgraph graph.pdf\n</code></pre> <p>The example above generates a dependency graph for the package <code>O2</code>, and saving the results to a PDF file named <code>graph.pdf</code>. This is what the graph looks like:</p> <p></p> <p>Packages in green are runtime dependencies, purple are build dependencies, while red packages are runtime dependencies in some cases, and build dependencies in others (this can indicate an error in the recipes).</p> <p>Connections are color-coded as well: blue connections indicate a runtime dependency whereas a grey connection indicate a build dependency.</p> <p>By default, <code>aliBuild deps</code> runs the usual system checks to exclude packages that can be taken from the system. If you want to display the full list of dependencies, you may want to use:</p> <pre><code>aliBuild deps O2 --no-system --outgraph graph.pdf\n</code></pre> <p>Additional useful options for <code>aliBuild deps</code> include:</p> <ul> <li><code>--neat</code>: Produce a graph with transitive reduction, removing edges that are   implied by other paths in the graph. This can make complex dependency graphs   easier to read.</li> <li><code>--outdot FILE</code>: Keep the intermediate Graphviz dot file in <code>FILE</code>. Useful if   you want to manually modify the graph or generate output in different formats.</li> </ul> <p>For example, to generate a simplified graph and keep the dot file:</p> <pre><code>aliBuild deps O2 --neat --outdot graph.dot --outgraph graph.pdf\n</code></pre> <p>Please run <code>aliBuild deps --help</code> for further information.</p>"},{"location":"user.html#using-the-packages-you-have-built","title":"Using the packages you have built","text":""},{"location":"user.html#loading-the-package-environment","title":"Loading the package environment","text":"<p>Environment for packages built using aliBuild is managed by Environment Modules and the wrapper script <code>alienv</code>. To list the available packages you can do:</p> <pre><code>alienv q\n</code></pre> <p>while:</p> <pre><code>alienv enter VO_ALICE@PackageA::VersionA[,VO_ALICE@PackageB::VersionB...]\n</code></pre> <p>will enter a shell with the appropriate environment set. Note that loading a toplevel package recursively sets the environment for all its dependencies.</p> <p>You can also execute a command with the proper environment without altering the current one. For instance:</p> <pre><code>alienv setenv VO_ALICE@AliRoot::latest -c aliroot -b\n</code></pre> <p>To see other commands consult the online manual:</p> <pre><code>alienv help\n</code></pre> <p>Environment Modules is required: the package is usually called <code>environment-modules</code> on Linux, or simply <code>modules</code> if using Homebrew on OSX.</p> <p>Note that <code>alienv</code> works exactly like the one found on CVMFS, but for local packages built with <code>aliBuild</code>.</p>"},{"location":"user.html#environment-for-packages-lacking-a-module-definition","title":"Environment for packages lacking a module definition","text":"<p>Some packages do not have a modulefile: this usually occurs for those which are not distributed on the Grid. If you think this is wrong feel free to submit a pull request or open an issue to the relevant packages.</p> <p>It is still possible to load the environment by sourcing the <code>init.sh</code> file produced for each package under the <code>etc/profile.d</code> subdirectory. For instance:</p> <pre><code>WORK_DIR=$PWD/sw source sw/slc7_x86-64/AliRoot/v5-08-02-1/etc/profile.d/init.sh\n</code></pre> <p>Dependencies are automatically loaded.</p>"}]}